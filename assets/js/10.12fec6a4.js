(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{191:function(e,t,r){"use strict";r.r(t);var a=r(0),s=Object(a.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"content"},[e._m(0),e._v(" "),r("p",[e._v("学习算法非常重要，因为解决同样的问题，往往可以使用多种算法。对于高效程序员来 说，知道哪种算法效率最高非常重要。比如，现在至少有六七种排序算法，如果知道快速 排序比选择排序效率更高，那么就会让排序过程变得高效。又比如，实现一个线性查找的 算法很简单，但是如果知道有时二分查找可能比线性查找快两倍以上，那你势必会写出一个更好的程序。深入学习数据结构和算法，不仅可以知道哪种数据结构和算法更高效，还会知道如何找出最适合解决手头问题的数据结构和算法。")]),e._v(" "),e._m(1),e._v(" "),r("p",[e._v("最近，通过"),r("a",{attrs:{href:"https://www.youtube.com/watch?v=t2CEgPsws3U&t=5249s",target:"_blank",rel:"noopener noreferrer"}},[e._v("这个youtube教程"),r("OutboundLink")],1),e._v("学习了数据结构，教程用"),r("code",[e._v("js")]),e._v("实现了列表、栈、链表、队列、字典、散列、集合、树和图。")]),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),r("p",[r("a",{attrs:{href:"https://codepen.io/webkws/pen/XvxoWw?editors=0012",target:"_blank",rel:"noopener noreferrer"}},[e._v("实现一个列表类, 及其使用"),r("OutboundLink")],1)]),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),r("p",[r("a",{attrs:{href:"https://codepen.io/beaucarnes/pen/yMBGbR?editors=0012",target:"_blank",rel:"noopener noreferrer"}},[e._v("栈的实现"),r("OutboundLink")],1)]),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),r("p",[r("a",{attrs:{href:"https://codepen.io/beaucarnes/pen/dvGeeq?editors=0012",target:"_blank",rel:"noopener noreferrer"}},[e._v("Set类的实现"),r("OutboundLink")],1)]),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),r("p",[r("a",{attrs:{href:"https://codepen.io/beaucarnes/pen/QpaQRG?editors=0012",target:"_blank",rel:"noopener noreferrer"}},[e._v("队列和优先队列"),r("OutboundLink")],1)]),e._v(" "),e._m(10),e._v(" "),e._m(11),e._v(" "),r("p",[r("a",{attrs:{href:"https://codepen.io/beaucarnes/pen/ryKvEQ?editors=0011",target:"_blank",rel:"noopener noreferrer"}},[e._v("实现二叉查找树"),r("OutboundLink")],1)]),e._v(" "),e._m(12),e._v(" "),r("p",[e._v("散列是一种常用的数据存储技术，散列后的数据可以快速地插入或取用。散列使用的数据 结构叫做散列表。在散列表上插入、删除和取用数据都非常快，但是对于查找操作来说却 效率低下，比如查找一组数据中的最大值和最小值。这些操作得求助于其他数据结构，二 叉查找树就是一个很好的选择。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://codepen.io/beaucarnes/pen/VbYGMb?editors=0012",target:"_blank",rel:"noopener noreferrer"}},[e._v("HashTable类"),r("OutboundLink")],1)]),e._v(" "),e._m(13),e._v(" "),r("p",[e._v("数组不总是组织数据的最佳数据结构。在数组中，添加和删 除元素也很麻烦，因为需要将数组中的其他元素向前或向后平移，以反映数组刚刚进行了 添加或删除操作。如果需要随机访问，数组仍然是 更好的选择。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://codepen.io/beaucarnes/pen/ybOvBq?editors=0011",target:"_blank",rel:"noopener noreferrer"}},[e._v("设计一个基于对象的链表"),r("OutboundLink")],1),e._v("\n以上实现较为繁琐，有个更简便的方式，增加了链表的查找\n"),r("a",{attrs:{href:"https://codepen.io/webkws/pen/wVQZGq",target:"_blank",rel:"noopener noreferrer"}},[e._v("链表简单版"),r("OutboundLink")],1),e._v(" "),r("a",{attrs:{href:"https://codepen.io/webkws/pen/wVQLaB?editors=1111",target:"_blank",rel:"noopener noreferrer"}},[e._v("双向链表"),r("OutboundLink")],1)]),e._v(" "),e._m(14),e._v(" "),e._m(15),e._v(" "),r("p",[r("a",{attrs:{href:"https://codepen.io/beaucarnes/pen/mmBNBd?editors=0011",target:"_blank",rel:"noopener noreferrer"}},[e._v("单词查找树"),r("OutboundLink")],1)]),e._v(" "),e._m(16),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.jianshu.com/p/6b526aa481b1",target:"_blank",rel:"noopener noreferrer"}},[e._v("介绍"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://codepen.io/beaucarnes/pen/JNvENQ?editors=0010",target:"_blank",rel:"noopener noreferrer"}},[e._v("地址"),r("OutboundLink")],1)]),e._v(" "),e._m(17),e._v(" "),r("p",[e._v("图形的实现方法很多")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://codepen.io/beaucarnes/pen/XgrXvw?editors=0012",target:"_blank",rel:"noopener noreferrer"}},[e._v("地址"),r("OutboundLink")],1)]),e._v(" "),e._m(18)])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"数据结构和算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法","aria-hidden":"true"}},[this._v("#")]),this._v(" 数据结构和算法")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构","aria-hidden":"true"}},[this._v("#")]),this._v(" 数据结构")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list","aria-hidden":"true"}},[this._v("#")]),this._v(" List")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("列表")]),this._v("是一组有序的数据。每个列表中的数据项称为元素。在 "),t("code",[this._v("JavaScript")]),this._v(" 中，列表中的元素 可以是任意数据类型。列表中可以保存多少元素并没有事先限定，实际使用时元素的数量 受到程序内存的限制。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"stacks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stacks","aria-hidden":"true"}},[this._v("#")]),this._v(" Stacks")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("栈")]),this._v("是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。咖啡厅内 的一摞盘子是现实世界中常见的栈的例子。只能从最上面取盘子，盘子洗净后，也只能摞 在这一摞盘子的最上面。栈被称为一种后入先出(LIFO，last-in-first-out)的数据结构。\n由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元 素，必须先拿掉上面的元素。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"sets"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sets","aria-hidden":"true"}},[this._v("#")]),this._v(" Sets")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("集合")]),this._v("是一种包含不同元素的数据结构。集合中的元素称为成员。集合的两个最重 要特性是:首先，集合中的成员是无序的;其次，集合中不允许相同成员存在")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"queues"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#queues","aria-hidden":"true"}},[this._v("#")]),this._v(" Queues")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("队列")]),this._v("的两种主要操作是:向队列中插入新元素和删除队列中的元素。插入操作也叫做入 队，删除操作也叫做出队。入队操作在队尾插入新元素，出队操作删除队头的元素")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"binary-search-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#binary-search-tree","aria-hidden":"true"}},[this._v("#")]),this._v(" Binary Search Tree")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("树")]),this._v("是一种非线性的数据结构，以分层的方式 存储数据。树被用来存储具有层级关系的数据，比如文件系统中的文件;树还被用来存储 有序列表。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"hash-tables"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash-tables","aria-hidden":"true"}},[this._v("#")]),this._v(" Hash Tables")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"linked-list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linked-list","aria-hidden":"true"}},[this._v("#")]),this._v(" Linked List")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"trie"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#trie","aria-hidden":"true"}},[this._v("#")]),this._v(" Trie")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("又称单词查找树，"),t("strong",[this._v("Trie树")]),this._v("，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"heap-max-and-min"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#heap-max-and-min","aria-hidden":"true"}},[this._v("#")]),this._v(" Heap (max and min)")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"graphs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#graphs","aria-hidden":"true"}},[this._v("#")]),this._v(" Graphs")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法","aria-hidden":"true"}},[this._v("#")]),this._v(" 算法")])}],!1,null,null,null);s.options.__file="data_structures.md";t.default=s.exports}}]);